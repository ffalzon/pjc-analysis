import numpy as np
from scipy.stats import truncnorm
import csv, os
import matplotlib.pyplot as plt
from scipy.stats import norm
import math

class Util:
    def __init__(self, params):
          pass
    
    @staticmethod
    def gen_normal_data(mean, scale, min_val, max_val, size, seed, round_to_int=True):
        a = (min_val - mean) / scale
        b = (max_val - mean) / scale
        truncnorm_dist = truncnorm(a=a, b=b, loc=mean, scale=scale)
        truncnorm_dist.random_state = np.random.RandomState(seed)
        data = truncnorm_dist.rvs(size=size)
        if round_to_int:
            data = data.round().astype(int)
        else:
            data = data.round(2)
        return data
    
    @staticmethod
    def write_results_to_csv(file_path, fields, results):
        file_empty = not os.path.exists(file_path) or os.stat(file_path).st_size == 0
        with open(file_path, 'a', newline='') as csvfile:
            writer = csv.writer(csvfile)
            if file_empty:
                writer.writerow(fields)
            writer.writerows(results)

    @staticmethod
    def compute_num_invocations(c : int, n : int, k : int):
        num_invocations = round(c * k * np.log2(n / k))
        return num_invocations
    
    @staticmethod
    def compute_num_invocations_from_list(c : int, n_k_list : list):
        for n_k_pair in n_k_list:
            n = n_k_pair[0]
            k = n_k_pair[1]
            num_invocations = round(c * k * np.log2(n / k))
            print(f"n={n}, c={c}, k={k} => num_invocations={num_invocations}")
        return num_invocations

    @staticmethod
    def plot_distribution(mean, scale, min_val, max_val, size=1000, seed=42):
        """
        Plots the distribution generated by the gen_normal_data method.
        
        Parameters:
        mean (float): Mean of the distribution.
        scale (float): Standard deviation of the distribution.
        min_val (float): Minimum value for truncation.
        max_val (float): Maximum value for truncation.
        size (int): Number of samples to generate for the histogram. Default is 1000.
        seed (int): Random seed for reproducibility. Default is 42.
        """
        # Generate truncated normal data
        data = Util.gen_normal_data(mean, scale, min_val, max_val, size, seed)

        # Set the bins to cover all integer values within the range
        bins = np.arange(min_val - 0.5, max_val + 1.5, 1)
        
        # Plot histogram of the data
        plt.hist(data, bins=bins, density=True, alpha=0.6, color='g', label='Histogram')
        
        # Plot the PDF of the truncated normal distribution
        x = np.linspace(min_val, max_val, 100)
        a = (min_val - mean) / scale
        b = (max_val - mean) / scale
        p = truncnorm.pdf(x, a=a, b=b, loc=mean, scale=scale)
        plt.plot(x, p, 'k', linewidth=2, label='PDF')
        
        # Adjust x-axis to display finer granularity
        plt.xticks(np.arange(min_val, max_val + 1, 1))  # Major ticks at every integer
        plt.minorticks_on()
        plt.gca().xaxis.set_minor_locator(plt.MultipleLocator(0.5))  # Minor ticks at every 0.5 units
        
        title = f'Truncated Normal Distribution with mean={mean}, scale={scale}'
        plt.title(title)
        plt.xlabel('Value')
        plt.ylabel('Density')
        plt.legend()
        plt.show()


    @staticmethod
    def plot_cs_num_invocations(c, n_values, file_dir):
        # Values of k to vary based on the minimum n in n_values
        k_values = np.linspace(1, min(n_values)-1, 500)  # Vary k from 1 to the smallest n-1
        str_c = str(c).replace('.', '_')
        filename = f"{file_dir}/cs_num_invocations_{str_c}.pdf"
        plt.figure(figsize=(6, 6))  # Set the figure size to be square

        for n in n_values:
            # Compute the function c * log2(n/k)
            y_values = c * k_values * np.log2(n / k_values)
            # Plotting each line
            plt.plot(k_values, y_values, label=f'$n = {n}$')

        # Adding labels and title
        plt.xlabel('k')
        text_ylabel = f"${c}"
        text_ylabel += r"\cdot k \log_2(\frac{n}{k})$"
        plt.ylabel(text_ylabel)
        plt.title('')
        plt.grid(True)
        plt.legend()
        # Make the plot square
        # plt.gca().set_aspect('equal', adjustable='box')
        # Save the plot to a PDF file
        plt.savefig(filename, bbox_inches='tight', format='pdf')
        # plt.show()

if __name__ == "__main__":
    # Example usage of the Util class
    """
    min_val = -10
    max_val = 10
    scale = (max_val - min_val) / 4  # 95% of the data will fall within 2 standard deviations
    Util.plot_distribution(mean=0, scale=scale, min_val=min_val, max_val=max_val, size=1000, seed=42)
    """ 
  
    # Example usage:
    # c = 2  # Example value for c
    c_list = [1.5, 2]
    n_values = [100, 1000, 2000, 5000, 10000]  # List of n values
    file_dir = "../../../USENIX_2025/Graphs"
    for c in c_list:
        Util.plot_cs_num_invocations(c, n_values, file_dir)
    # n_k_list = [(100, 10), (100, 20), (1000, 100), (1000, 200)]
    # Util.compute_num_invocations_from_list(c, n_k_list)